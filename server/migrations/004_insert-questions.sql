--difficulty 0
INSERT INTO Questions(title, category, difficulty, description, input, output, suggestedAnswer) VALUES('Two Sum', 'Array', 0, 'Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.', '{"nums = [2,7,11,15], target = 9", "nums = [3,2,4], target = 6","nums = [3,3], target = 6"}', '{"[0,1]", "[1,2]", "[0,1]"}', 'import java.util.HashMap;import java.util.Scanner;import java.util.Map;class Solution {    public int[] twoSum(int[] nums, int target) {        Map<Integer, Integer> numMap = new HashMap<>();        for (int i = 0; i < nums.length; i++) {            int complement = target - nums[i];            if (numMap.containsKey(complement)) {                return new int[] { numMap.get(complement), i };            } else {                numMap.put(nums[i], i);            }        }        return new int[] {};    }}');
INSERT INTO Questions(title, category, difficulty, description, input, output, suggestedAnswer) VALUES('Palindrome Number', 'Math', 0, 'Given an integer x, return true if x is palindrome integer.An integer is a palindrome when it reads the same backward as forward. For example, 121 is palindrome while 123 is not.', '{"x = 121", "x = -121", "x = 10", "x = -101"}','{"true", "false", "false", "false"}', 'class Solution {    public boolean isPalindrome(int x) {        if (x < 0) {            return false;        } else if (x == 0) {            return true;        } else {            int y = x;            if (y % 10 == 0 ) {                return false;            }            long reversedValue = 0;            while (y != 0) {                long lastDigit = y % 10;                reversedValue = reversedValue * 10 + lastDigit;                y /= 10;            }            if (reversedValue == (long)x) {                return true;            } else {                return false;            }        }    }}');
INSERT INTO Questions(title, category, difficulty, description, input, output, suggestedAnswer) VALUES('Same Tree', 'Tree', 0, 'Given the roots of two binary trees p and q, write a function to check if they are the same or not.Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.', '{"p = [1,2,3], q = [1,2,3]", "p = [1,2], q = [1,null,2]", "p = [1,2,1], q = [1,1,2]"}', '{"true", "false", "false"}', 'class Solution {    public boolean isSameTree(TreeNode p, TreeNode q) {        if (p == null && q == null) {            return true;        }        if ((p != null && q== null) || (p == null && q != null)) {            return false;        }        int currPValue = p.val;        int currQValue = q.val;        if (currPValue != currQValue) {            return false;        }         else {            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);        }    }}');
INSERT INTO Questions(title, category, difficulty, description, input, output, suggestedAnswer) VALUES('Plus One', 'Array', 0, 'You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0''s.Increment the large integer by one and return the resulting array of digits.', '{"digits = [1,2,3]", "digits = [4,3,2,1]", "digits = [0]", "digits = [9]"}','{"[1,2,4]", "[4,3,2,2]", "[1]", "[1,0]"}', 'import java.util.List;import java.util.ArrayList;class Solution {    public int[] plusOne(int[] digits) {       if(digits == null || digits.length == 0){            int[] temp={1};            return temp;        }                int carry=1;        int i;        for( i=digits.length-1;i>=0;i--){            if(digits[i]==9){                digits[i]=0;            }            else{                carry+=digits[i];                digits[i]=carry;                break;            }        }        if(i<0){            int[] result = new int[digits.length+1];            result[0]=1;            return result;        }else            return digits;    }}');
INSERT INTO Questions(title, category, difficulty, description, input, output, suggestedAnswer) VALUES('Climbing Stairs', 'Dynamic Programming', 0, 'You are climbing a staircase. It takes n steps to reach the top.Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?', '{"n = 2", "n = 3"}','{"2", "3"}', 'class Solution {    public int climbStairs(int n) {        int[] array = new int[n+1];        array[0] = 1;        array[1] = 1;        for (int i = 2; i <= n; i++) {            array[i] = array[i-1] + array[i-2];        }        return array[n];    }}');
INSERT INTO Questions(title, category, difficulty, description, input, output, suggestedAnswer) VALUES('Remove Duplicates from Sorted List', 'Linked List', 0, 'Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.', '{"head = [1,1,2]", "head = [1,1,2,3,3]"}','{"[1,2]", "[1,2,3]"}', 'class Solution {    public ListNode deleteDuplicates(ListNode head) {        ListNode dummy = new ListNode();        ListNode newHead = dummy;        dummy.next = head;        dummy = dummy.next;        if (head == null) {            return head;        }        while(head.next != null) {            ListNode curr = head.next;            if (curr.val == head.val) {                head = curr; //move on to the next element            } else {                dummy.next = curr;                dummy = dummy.next;                head = curr;            }        }        dummy.next = head.next;        return newHead.next;    }}');
INSERT INTO Questions(title, category, difficulty, description, input, output, suggestedAnswer) VALUES('Merge Sorted Array', 'Array', 0, 'You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.Merge nums1 and nums2 into a single array sorted in non-decreasing order.The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.', '{"nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3", "nums1 = [1], m = 1, nums2 = [], n = 0"}','{"[1,2,2,3,5,6]", "[1]"}', 'class Solution {    public void merge(int[] nums1, int m, int[] nums2, int n) {        int num1Pointer = m - 1;        int num2Pointer = n - 1;        int indexPointer = nums1.length - 1;        while (indexPointer >= 0) {            if (num1Pointer < 0) {                nums1[indexPointer] = nums2[num2Pointer--];            } else if (num2Pointer < 0) {                nums1[indexPointer] = nums1[num1Pointer--];            } else {                if (nums1[num1Pointer] > nums2[num2Pointer]) {                    nums1[indexPointer] = nums1[num1Pointer--];                } else {                    nums1[indexPointer] = nums2[num2Pointer--];                }            }            indexPointer--;        }    }}');
INSERT INTO Questions(title, category, difficulty, description, input, output, suggestedAnswer) VALUES('Same Tree', 'Tree', 0, 'Given the roots of two binary trees p and q, write a function to check if they are the same or not.Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.', '{"p = [1,2,3], q = [1,2,3]", "p = [1,2,3], q = [1,null,2]"}','{"true", "false"}', 'class Solution {    public boolean isSameTree(TreeNode p, TreeNode q) {        if (p == null && q == null) {            return true;        }        if ((p != null && q== null) || (p == null && q != null)) {            return false;        }        int currPValue = p.val;        int currQValue = q.val;        if (currPValue != currQValue) {            return false;        }         else {            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);        }    }}');
INSERT INTO Questions(title, category, difficulty, description, input, output, suggestedAnswer) VALUES('Best Time to Buy and Sell Stock', 'Array', 0, 'You are given an array prices where prices[i] is the price of a given stock on the ith day.You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.', '{"prices = [7,1,5,3,6,4]", "prices = [7,6,4,3,1]"}','{"5", "0"}', 'class Solution {    public int maxProfit(int[] prices) {        int min = Integer.MAX_VALUE;        int maxProfit = 0;        for (int i = 0; i < prices.length; i++) {            if (prices[i] < min) {                min = prices[i];            } else {                maxProfit = Math.max(maxProfit, prices[i] - min);            }        }        return maxProfit;    }}');
INSERT INTO Questions(title, category, difficulty, description, input, output, suggestedAnswer) VALUES('Linked List Cycle', 'Linked List', 0, 'Given head, the head of a linked list, determine if the linked list has a cycle in it.There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail''s next pointer is connected to. Note that pos is not passed as a parameter.Return true if there is a cycle in the linked list. Otherwise, return false.', '{"head = [3,2,0,-4], pos = 1", "head = [1,2], pos = 0"}','{"true", "true"}', 'public class Solution {    public boolean hasCycle(ListNode head) {        if (head == null) {            return false;        }        head.val = Integer.MIN_VALUE;        while (head.next != null) {            head = head.next;            if (head.val == Integer.MIN_VALUE) {                return true;            } else {                head.val = Integer.MIN_VALUE;            }        }        return false;    }}');
--difficulty 1
INSERT INTO Questions(title, category, difficulty, description, input, output, suggestedAnswer) VALUES('Add Two Numbers', 'Linked List', 1, 'You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.You may assume the two numbers do not contain any leading zero, except the number 0 itself.', '{"l1 = [2,4,3], l2 = [5,6,4]", "l1 = [0], l2 = [0]", "l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]"}','{"[7,0,8]", "[0]", "[8,9,9,9,0,0,0,1]"}', 'class Solution {    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {        ListNode dummy = new ListNode();        ListNode head = dummy;        int carry = 0;        while (l1 != null || l2 != null) {            int l1Value = l1 != null ? l1.val : 0;            int l2Value = l2 != null ? l2.val : 0;            int sum = l1Value + l2Value + carry;            int lastDigit = sum % 10;            carry = sum / 10;            dummy.next = new ListNode(lastDigit);            dummy = dummy.next;            if (l1 != null) {                l1 = l1.next;            }            if (l2 != null) {                l2 = l2.next;            }        }        if (carry > 0) {            dummy.next = new ListNode(1);            dummy = dummy.next;        }        return head.next;}}');
INSERT INTO Questions(title, category, difficulty, description, input, output, suggestedAnswer) VALUES('Reverse Integer', 'Math', 1, 'Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.Assume the environment does not allow you to store 64-bit integers (signed or unsigned).', '{"x = 123", "x = -123", "x = 120", "x = 0"}','{"321", "-321", "21", "0"}', 'class Solution {    public int reverse(int x) {        boolean isNegative = false;        long y = x;        long reversedValue = 0;        if (x < 0) {            y *= -1;            isNegative = true;        }         if (y % 10 == 0) {                y /= 10;        }        while (y != 0) {            long lastDigit = y % 10;            reversedValue = reversedValue * 10 + lastDigit;            y /= 10;        }                // check if overflows               if (isNegative) {            long intermediateAnswer = -1 * reversedValue;           if (intermediateAnswer < Integer.MIN_VALUE) {               return 0;           } else {               int answer = (int)intermediateAnswer;               return answer;           }       } else {            if (reversedValue > Integer.MAX_VALUE) {               return 0;           } else {               return (int)reversedValue;           }       }     }}');
INSERT INTO Questions(title, category, difficulty, description, input, output, suggestedAnswer) VALUES('Contain Most Water', 'Array', 1, 'Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of the line i is at (i, ai) and (i, 0). Find two lines, which, together with the x-axis forms a container, such that the container contains the most water.Notice that you may not slant the container.', '{"height = [1,8,6,2,5,4,8,3,7]", "height = [1,1]", "height = [4,3,2,1,4]", "height = [1,2,1]"}','{"49", "1", "16", "2"}', 'class Solution {    public int maxArea(int[] height) {        int leftIndex = 0;        int rightIndex = height.length - 1;        int maxArea = 0;        while (rightIndex > leftIndex) {            if (height[rightIndex] > height[leftIndex]) {                maxArea = Math.max(maxArea, height[leftIndex] * (rightIndex - leftIndex));                leftIndex++;            } else {                maxArea = Math.max(maxArea, height[rightIndex] * (rightIndex - leftIndex));                rightIndex--;            }        }        return maxArea;    }}');
INSERT INTO Questions(title, category, difficulty, description, input, output, suggestedAnswer) VALUES('3 Sum', 'Array', 1, 'Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.Notice that the solution set must not contain duplicate triplets.', '{"nums = [-1,0,1,2,-1,-4]", "nums = []", "nums = [0]"}','{"[[-1,-1,2],[-1,0,1]]", "[]", "[]"}', 'class Solution {    public List<List<Integer>> threeSum(int[] nums) {        Arrays.sort(nums);        List<List<Integer>> answer = new ArrayList<>();                for (int i = 0; i < nums.length - 2; i++) {            if (i == 0 || (i > 0 && nums[i] != nums[i-1])) {                int low = i + 1;                int high = nums.length - 1;                int sum = 0 - nums[i];                                while (low < high) {                    if (nums[low] + nums[high] == sum) {                        answer.add(Arrays.asList(nums[i], nums[low], nums[high]));                        while (low < high && nums[low] == nums[low + 1]) low++;                        while (low < high && nums[high] == nums[high - 1]) high--;                        low++;                        high--;                    } else if (nums[low] + nums[high] > sum) {                        high--;                    } else {                        low++;                    }                }            }        }        return answer;    }}');
INSERT INTO Questions(title, category, difficulty, description, input, output, suggestedAnswer) VALUES('4 Sum', 'Array', 1, 'Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:0 <= a, b, c, d < na, b, c, and d are distinct.nums[a] + nums[b] + nums[c] + nums[d] == target. You may return the answer in any order.', '{"nums = [1,0,-1,0,-2,2], target = 0", "nums = [2,2,2,2,2], target = 8"}','{"[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]", "[[2,2,2,2]]"}', '/** * @param {number[]} nums * @param {number} target * @return {number[][]} */var fourSum = function(nums, target) {    //to store unique pairs    let setOfPairs = new Set();    nums.sort((a,b) => a-b);    let result = [];    for(let i = 0; i < nums.length - 3; i++) {        for (let j = i+1; j < nums.length - 2; j++) {            let k = j + 1;            let l = nums.length - 1;            while (k < l) {                let sum = nums[i] + nums[j] + nums[k] + nums[l];                if(sum === target) {                    let value = [nums[i], nums[j], nums[k], nums[l]];                    if(!setOfPairs.has(JSON.stringify(value))) {                        setOfPairs.add(JSON.stringify(value));                        result.push(value);                    }                    k++;                    l--;                } else if (sum > target) {                    l--;                } else {                    k++;                }            }            while(nums[j] === nums[j + 1]) j++;        }        while(nums[i] === nums[i + 1]) i++;    }    return result;};');
INSERT INTO Questions(title, category, difficulty, description, input, output, suggestedAnswer) VALUES('Remove Nth Node From End of List', 'Linked List', 1, 'Given the head of a linked list, remove the nth node from the end of the list and return its head.', '{"head = [1,2,3,4,5], n = 2", "head = [1], n = 1", "head = [1,2], n = 1"}','{"[1,2,3,5]", "[]", "[1]"}', 'class Solution {    public ListNode removeNthFromEnd(ListNode head, int n) {        if (head.next == null && n == 1) {            return head.next;        }        ListNode dummy = new ListNode();        ListNode h1 = dummy;        ListNode pointer = head;        for (int i = 0; i < n-1; i++) {            pointer = pointer.next;        }        while (pointer.next != null) {            dummy.next = head;            dummy = dummy.next;            head = head.next;            pointer = pointer.next;        }        dummy.next = head.next;        return h1.next;    }}');
INSERT INTO Questions(title, category, difficulty, description, input, output, suggestedAnswer) VALUES('Swap Nodes in Pairs', 'Linked List', 1, 'Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list''s nodes (i.e., only nodes themselves may be changed.)', '{"head = [1,2,3,4]", "head = []", "head = [1]"}','{"[2,1,4,3]", "[]", "[1]"}', '/** * @param {ListNode} head * @return {ListNode} */var swapPairs = function(head) {    if (head == null || head.next == null) {        return head;    }    var pointer1 = head;    var pointer2 = head.next;    pointer1.next = pointer2.next;    pointer2.next = pointer1;    var temp = pointer2;    pointer2 = pointer1;    pointer1 = temp;    var ans = pointer1;        pointer1 = pointer1.next;    pointer2 = pointer2.next;    if (pointer1 == null || pointer2 == null) {        return ans    }    var pointer0 = pointer1;    pointer1 = pointer1.next;    pointer2 = pointer2.next;        while (pointer1 != null && pointer2 !== null) {        pointer1.next = pointer2.next;        pointer2.next = pointer1;        temp = pointer2;        pointer2 = pointer1;        pointer1 = temp;        pointer0.next = pointer1;        pointer1 = pointer1.next;        pointer2 = pointer2.next;        pointer0 = pointer0.next;        if (pointer1 == null || pointer2 == null) {            return ans        }        pointer1 = pointer1.next;        pointer0 = pointer0.next;        pointer2 = pointer2.next;    }    return ans};');
INSERT INTO Questions(title, category, difficulty, description, input, output, suggestedAnswer) VALUES('Divide Two Integers', 'Math', 1, 'Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.Return the quotient after dividing dividend by divisor.The integer division should truncate toward zero, which means losing its fractional part. For example, truncate(8.345) = 8 and truncate(-2.7335) = -2.Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. For this problem, assume that your function returns 231 − 1 when the division result overflows.', '{"dividend = 10, divisor = 3", "dividend = 7, divisor = -3", "dividend = 0, divisor = 1"}','{"3", "-2", "0"}', ' * @param {number} dividend * @param {number} divisor * @return {number} */var divide = function(dividend, divisor) {    let isSigned = false;    //Sign of the answer    isSigned = dividend < 0 ? !isSigned : isSigned;    isSigned = divisor < 0 ? !isSigned : isSigned;    dividend = Math.abs(dividend);    divisor = Math.abs(divisor);    if (dividend < divisor) return 0;    let q = 0;    while(dividend >=  divisor) {        let val = divisor;        let multiplier = 1;        while (val + val <= dividend) {            val += val;            multiplier += multiplier;        }        dividend -= val;        q += multiplier    }    //return answer in range    q = isSigned ? Math.max(-2147483648, 0-q) : Math.min(2147483647, q);    return q;};');
INSERT INTO Questions(title, category, difficulty, description, input, output, suggestedAnswer) VALUES('Search in Rotated Sorted Array', 'Array', 1, 'There is an integer array nums sorted in ascending order (with distinct values).Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.You must write an algorithm with O(log n) runtime complexity.', '{"nums = [4,5,6,7,0,1,2], target = 0", "nums = [4,5,6,7,0,1,2], target = 3", "nums = [1], target = 0"}','{"4", "-1", "-1"}', 'class Solution {    public int search(int[] nums, int target) {        int left = 0;        int right = nums.length - 1;        while (left < right) { //finding the pivot index            int midpoint = left + (right - left) / 2;            if (nums[midpoint] > nums[right]) {                left = midpoint + 1;            } else {                right = midpoint;            }        }                int start = left;        left = 0;        right = nums.length - 1;                if (target >= nums[start] && target <= nums[right]) {            left = start;        } else {            right = start;        }        while (right >= left) {            int midpoint = left + (right - left) / 2;            if (nums[midpoint] == target) {                return midpoint;            } else if (nums[midpoint] < target) {                left = midpoint + 1;            } else {                right = midpoint - 1;            }        }        return -1;    }}');
INSERT INTO Questions(title, category, difficulty, description, input, output, suggestedAnswer) VALUES('Combination Sum', 'Array', 1, 'Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.It is guaranteed that the number of unique combinations that sum up to target is less than 150 combinations for the given input.', '{"candidates = [2,3,6,7], target = 7", "candidates = [2,3,5], target = 8", "candidates = [2], target = 1"}','{"[[2,2,3],[7]]", "[[2,2,2,2],[2,3,3],[3,5]]", "[]"}', 'class Solution {    public List<List<Integer>> combinationSum(int[] candidates, int target) {        List<List<Integer>> output = new ArrayList<>();        Arrays.sort(candidates);        findCombinations(candidates, 0, target, new ArrayList<Integer>(), output);        return output;    }        public void findCombinations(int[] candidates, int index, int target, List<Integer> current, List<List<Integer>> output) {        if (target == 0) {            output.add(new ArrayList<>(current));            return;        }        if (target < 0) {            return;        }                for (int i = index; i < candidates.length; i++) {            current.add(candidates[i]);            findCombinations(candidates, i, target - candidates[i], current, output);            current.remove(current.size() - 1);        }    }}');
-- difficulty 2
INSERT INTO Questions(title, category, difficulty, description, input, output, suggestedAnswer) VALUES('Merge k Sorted Lists', 'Array', 2, 'You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.Merge all the linked-lists into one sorted linked-list and return it.', '{"lists = [[1,4,5],[1,3,4],[2,6]]", "lists = []", "lists[[]]"}','{"[1,1,2,3,4,4,5,6]", "[]", "[]"}', 'class Solution {    public ListNode mergeKLists(ListNode[] lists) {        PriorityQueue<Integer> minHeap = new PriorityQueue<>();        for (ListNode node: lists) {            while (node != null) {                minHeap.add(node.val);                node = node.next;            }        }        ListNode dummy = new ListNode();        ListNode head = dummy;        while (!minHeap.isEmpty()) {            dummy.next = new ListNode(minHeap.poll());            dummy = dummy.next;        }        dummy.next = null;        return head.next;    }}');
INSERT INTO Questions(title, category, difficulty, description, input, output, suggestedAnswer) VALUES('Reverse Nodes in k-Group', 'Linked List', 2, 'Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.You may not alter the values in the list''s nodes, only nodes themselves may be changed.', '{"head = [1,2,3,4,5], k = 2", "head = [1,2,3,4,5], k = 3", "head = [1,2,3,4,5], k = 1"}','{"[2,1,4,3,5]", "[3,2,1,4,5]", "[1,2,3,4,5]"}', 'public class Pair {    public final ListNode head;    public final ListNode tail;    public Pair (ListNode head, ListNode tail) {        this.head = head;        this.tail = tail;    }}class Solution {    public ListNode reverseKGroup(ListNode head, int k) {        if (k == 1 || head == null) {            return head;        }        int counter = 1;        boolean flag = true;        ListNode head1 = head;        ListNode head2 = head;        ListNode head3 = head;        while (true) {            counter++;            head3 = head3.next; //2            if (head3 == null) {                    return head1;                }            if (counter % k == 0) {            System.out.println(counter);                if (flag) {                    head1 = reverseLinkListPair(head2, head3);                    head2 = head1;                    for (int i = 0; i < k - 1; i++) {                        head2 = head2.next;                    }                    head3 = head2;                    flag = false;                } else {                    ListNode newHead = reverseLinkListPair(head2.next, head3);                    head2.next = newHead;                    for (int i = 0; i < k; i++) {                        head2 = head2.next;                    }                    head3 = head2;                }            }        }    }        public ListNode reverseLinkListPair(ListNode head, ListNode tail) {        ListNode nextHead = tail.next;        tail.next = null;        ListNode prev = null;        ListNode toReturn = head;        ListNode dummy = head;        while (dummy.next != null) {            ListNode nextPointer = dummy.next;            dummy.next = prev;            prev = dummy;            dummy = nextPointer;        }        dummy.next = prev;        toReturn.next = nextHead;        return dummy;    }    }');
INSERT INTO Questions(title, category, difficulty, description, input, output, suggestedAnswer) VALUES('Binary Tree Maximum Path Sum', 'Linked List', 2, 'A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.The path sum of a path is the sum of the node''s values in the path.Given the root of a binary tree, return the maximum path sum of any path.', '{"root = [1,2,3]", "root = [-10,9,20,null,null,15,7]"}','{"6", "42"}', 'class Solution {    int ans;    public int maxPathSum(TreeNode root) {        ans=Integer.MIN_VALUE;        recursion(root);        return ans;    }    public int recursion(TreeNode root){        if(root==null) return -2000;        int left = recursion(root.left);        int right = recursion(root.right);        int r = Math.max(root.val, root.val+Math.max(left,right));        ans=Math.max(ans, Math.max(r,root.val+left+right));        return r;           }}');
INSERT INTO Questions(title, category, difficulty, description, input, output, suggestedAnswer) VALUES('Median of Two Sorted Arrays', 'Array', 2, 'Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.The overall run time complexity should be O(log (m+n)).', '{"nums1 = [1,3], nums2 = [2]", "nums1 = [1,2], nums2 = [3,4]", "nums1 = [0,0], nums2 = [0,0]", "nums1 = [], nums2 = [1]", "nums1 = [2], nums2 = []"}','{"2.00000", "2.50000", "0.00000", "2.00000", "2.00000"}', 'double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {        std::vector<int> dst;        std::merge(nums1.begin(), nums1.end(), nums2.begin(), nums2.end(), std::back_inserter(dst));        int n = dst.size();        if (n % 2 != 0) return (double)dst[n / 2];        return (double)(dst[(n - 1) / 2] + dst[n / 2]) / 2.0;    }');
INSERT INTO Questions(title, category, difficulty, description, input, output, suggestedAnswer) VALUES('Trapping Rain Water', 'Array', 2, 'Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.', '{"height = [0,1,0,2,1,0,1,3,2,1,2,1]", "height = [4,2,0,3,2,5]"}','{"6", "9"}', 'class Solution:    def trap(self, height: List[int]) -> int:        water = 0        left = 0        right = len(height)-1                highest = 0        while left < right:            if height[left] < height[right]:                if height[left] > highest:                    highest = height[left]                left+=1                water += max(0, highest-height[left])            else:                if height[right] > highest:                    highest = height[right]                right-=1                water += max(0, highest-height[right])        return water');
INSERT INTO Questions(title, category, difficulty, description, input, output, suggestedAnswer) VALUES('Largest Rectangle in Histogram', 'Array', 2, 'Given an array of integers heights representing the histogram''s bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.', '{"heights = [2,1,5,6,2,3]", "heights = [2,4]"}','{"10", "4"}', 'class Solution:    def largestRectangleArea(self, heights: List[int]) -> int:        heights.append(0) # to force pop for all remaining items        s = [0] # stack of indices initialized with the first one        ans = heights[0]        for i in range(1, len(heights)):            while s and heights[s[-1]] > heights[i]:                h = heights[s.pop()]                rb = s[-1] if s else -1 # reachback                w = i - rb - 1                ans = max(ans, w*h)            s.append(i)        return ans');
INSERT INTO Questions(title, category, difficulty, description, input, output, suggestedAnswer) VALUES('Best Time to Buy and Sell Stock III', 'Array', 2, 'You are given an array prices where prices[i] is the price of a given stock on the ith day.Find the maximum profit you can achieve. You may complete at most two transactions.Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).', '{"prices = [3,3,5,0,0,3,1,4]", "prices = [1,2,3,4,5]", "prices = [7,6,4,3,1]", "prices = [1]"}','{"6", "4", "0", "0"}', 'int maxProfit(vector<int>& prices) {        int min_price1 = INT_MAX;        int profit1 = 0;        int min_price2 = INT_MAX;        int profit2 = 0;                for(int i=0;i<prices.size();i++){            min_price1 = min(min_price1 , prices[i]);            profit1 = max(profit1 , prices[i] - min_price1);                        min_price2 = min(min_price2 , prices[i] - profit1);            profit2 = max(profit2 , prices[i] - min_price2);        }        return profit2;    }');
INSERT INTO Questions(title, category, difficulty, description, input, output, suggestedAnswer) VALUES('Candy', 'Greedy', 2, 'There are n children standing in a line. Each child is assigned a rating value given in the integer array ratings.You are giving candies to these children subjected to the following requirements:Each child must have at least one candy.Children with a higher rating get more candies than their neighbors.Return the minimum number of candies you need to have to distribute the candies to the children.', '{"ratings = [1,0,2]", "ratings = [1,2,2]"}','{"5", "4"}', 'class Solution:    def candy(self, ratings: List[int]) -> int:        candies = [1 for i in range(len(ratings))]        for i in range(1, len(ratings)):            if ratings[i] > ratings[i-1]:                candies[i] = candies[i-1] + 1        for i in range(len(ratings)-2, -1, -1):            if ratings[i] > ratings[i+1]:                candies[i] = max(candies[i], candies[i+1] + 1)        return sum(candies)');
INSERT INTO Questions(title, category, difficulty, description, input, output, suggestedAnswer) VALUES('Max Points on a Line', 'Hash Table', 2, 'Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane, return the maximum number of points that lie on the same straight line.', '{"points = [[1,1],[2,2],[3,3]]", "points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]"}','{"3", "4"}', 'class Solution {public:    int maxPoints(vector<vector<int>>& points) {        int ans = 0;        int n = points.size();        if(n < 3)            return n;        for(int i = 0;i<n;i++){            map<pair<int,int>, int> mp;            for(int  j = 0;j<n;j++){                if(i != j){                    int dy = (points[j][1] - points[i][1]);                    int dx = (points[j][0] - points[i][0]);                    int g = __gcd(dy,dx);                    mp[{dy/g,dx/g}]++;                }            }             for(auto k : mp){                ans = max(ans,k.second);            }        }        return ans+1;// extra 1 because it didn''t include itself.    }};');
INSERT INTO Questions(title, category, difficulty, description, input, output, suggestedAnswer) VALUES('Find Minimum in Rotated Sorted Array II', 'Array', 2, 'Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,4,4,5,6,7] might become:[4,5,6,7,0,1,4] if it was rotated 4 times.[0,1,4,4,5,6,7] if it was rotated 7 times.Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].Given the sorted rotated array nums that may contain duplicates, return the minimum element of this array.You must decrease the overall operation steps as much as possible.', '{"nums = [1,3,5]", "nums = [2,2,2,0,1]"}','{"1", "0"}', 'class Solution {    public int findMin(int[] nums) {        if (nums == null || nums.length == 0) {            throw new IllegalArgumentException("Input is invalid");        }        int len = nums.length;        if (len == 1 || nums[0] < nums[len - 1]) {            return nums[0];        }        if (len == 2) {            return Math.min(nums[0], nums[1]);        }        int start = 0;        int end = len - 1;        while (start < end) {            if (nums[start] < nums[end]) {                return nums[start];            }            int mid = start + (end - start) / 2;            while (start < mid && nums[start] == nums[mid] && nums[mid] == nums[end]) {                start++;                end--;            }            if (nums[mid] <= nums[end]) {                end = mid;            } else {                start = mid + 1;            }        }        return nums[start];    }}');
